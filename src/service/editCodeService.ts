import * as vscode from 'vscode';

export class EditCodeService {
    private codeEditors: Map<string, vscode.TextEditor> = new Map();
    private documentService?: { movePanelToRight: (docName: string) => void };

    public setDocumentService(documentService: { movePanelToRight: (docName: string) => void }) {
        this.documentService = documentService;
    }

    public async editCode(mainTitle: string, sectionTitle: string, docName?: string) {
        const key = `${mainTitle}_${sectionTitle}`;

        const existingEditor = this.codeEditors.get(key);
        if (existingEditor) {
            await vscode.window.showTextDocument(existingEditor.document, {
                viewColumn: vscode.ViewColumn.One,
                preserveFocus: false
            });
            return;
        }

        try {
            // 原子性操作：要么都成功，要么都失败
            await this.performAtomicEditCode(mainTitle, sectionTitle, docName);

        } catch (error) {
            vscode.window.showErrorMessage(`Failed to open code editor: ${error}`);
        }
    }

    private async performAtomicEditCode(mainTitle: string, sectionTitle: string, docName?: string) {
        const key = `${mainTitle}_${sectionTitle}`;

        try {
            const document = await vscode.workspace.openTextDocument({
                language: 'python',
                content: this.getInitialCodeTemplate(mainTitle, sectionTitle)
            });

            const editor = await vscode.window.showTextDocument(document, {
                viewColumn: vscode.ViewColumn.One,
                preserveFocus: false
            });

            await this.setEditorLabel(editor, `${mainTitle} - ${sectionTitle}`);

            // 2. 移动文档面板到右侧 (ViewColumn.Two)
            if (docName && this.documentService) {
                this.documentService.movePanelToRight(docName);
            }

            // 只有在所有操作都成功后，才保存编辑器引用
            this.codeEditors.set(key, editor);

            // 监听编辑器关闭事件
            const disposable = vscode.window.onDidChangeVisibleTextEditors(editors => {
                if (!editors.includes(editor)) {
                    this.codeEditors.delete(key);
                    disposable.dispose();
                }
            });

        } catch (error) {
            try {
                await vscode.commands.executeCommand('workbench.action.closeActiveEditor');

                await vscode.commands.executeCommand('vscode.setEditorLayout', {
                    orientation: 0,
                    groups: [{ size: 1.0 }]
                });
            } catch (recoveryError) {
                console.warn('Failed to recover from error:', recoveryError);
            }
            throw error;
        }
    }

    private getInitialCodeTemplate(mainTitle: string, sectionTitle: string): string {
        return `# ${mainTitle} - ${sectionTitle}
# Generated by LeetML Extension

def ${sectionTitle.toLowerCase().replace(/\s+/g, '_')}_function():
    """
    Implementation for ${sectionTitle}
    """
    pass

if __name__ == "__main__":
    # Test code here
    pass
`;
    }

    private async setEditorLabel(editor: vscode.TextEditor, label: string) {
        // 使用VS Code的私有API设置标签页名称（如果可用）
        // 对于未命名文档，默认会显示"Untitled-X"，这里我们保持原样
        // 用户可以通过配置隐藏或自定义标签页显示
    }

    public dispose() {
        this.codeEditors.clear();
    }
}